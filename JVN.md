学习方法：理论 实操  总结 三步曲
架构图


1. 何为线程，进程，管程？----------------------------------

2021年08月15日15:18:32

操作系统的设计，因此可以归结为三点：
（1）以多进程形式，允许多个任务同时运行；
（2）以多线程形式，允许单个任务分成不同的部分运行；
（3）提供协调机制，一方面防止进程之间和线程之间产生冲突，另一方面允许进程之间和线程之间共享资源。
一个进程可能包含多个线程
什么是管程：Monitor(监视器)，也就是我们平时所说的锁
Monitor其实是一种同步机制， 他的义务是保证(同一时间)只有一个线程可以访问被保护的数据和代码。
JVM中同步是基于进入和退出监视器对象(Monitor,管程对象)来实现的，每个对象实例都会有一.个Monitor对象，
Monitor对象会和Java对象. 同创建 并销毁，它底层 是由C++语言来实现的。

2. 谈谈JVM虚拟机之字节码指令集-同步指令----------------------------------
   同步控制指令
   java虚拟机支持两种同步结构：
   ● 方法级的同步
   ● 方法内部一段指令序列的同步
   这两种同步都是使用monitor指令来支持的

方法级的同步：是隐式的，即无须通过字节码指令来控制，它实现在方法调用和返回操作之中
虚拟机可以从方法常量池的方法表结构中的 ACC_SYNCHRONIZED 访问标志得知一个方法是否声明为同步方法
当调用万法时调用指令将会检查方法的ACC_SYNCHRONIZED访问标志是否设置
若设置了访问标志执行线程将先持有同步锁，然后执行方法。最后在方法完成（无论是正常完成还是非正常完成）时释放同步锁。
在方法执行期间，执行线程持有了同步锁(管程)，其他任何线程都无法再获得同一个锁(管程)
如果一个同步方法执行期间抛出了异常，并且在方法内部无法处理此异常，那这个同步方法所持有的锁将在异常抛到同步方法之外时自动释放

方法内指定指令序列的同步
同步一段指令集序列通常是由Java中的synchronized语句块来表示的
Jvm的指令集有monitorenter和monitorexit两条指令来支持synchronized关键字的语义
当一个线程进入同步代码块时，它使用monitorenter指令请求进入。
如果当前对象的监视器计数器为0，则它会被准许进入。
若计数器为1，则判断持有当前监视器的线程是否为自己，如果是自己则进入，否则进行等待，直到对象的监视器计数器为0,才会被允许进入同步块。
当线程退出同步块时，需要使用monitorexit声明退出。在Java虚拟机中，任何对象都有一个监视器与之相关联，用来判断对象是否被锁定，当监视器被持有后，对象处于锁定状态。
指令monitorenter和monitorexit在执行时，都需要在操作数栈顶压入对象,之后monitorenter和monitorexit的锁定和释放都是针对这个对象的监视器进行的。
————————————————
版权声明：本文为CSDN博主「余飘飘」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_43540696/article/details/116353504
2.1 (100%)用户线程和守护线程有什么区别？
守护线程：是一种特殊的线程，在后台默默地完成一些系统的服务，比如垃圾回收线程
用户线程：是系统的工作线程，它会完成这个程序需要完成的业务操作

当程序中所有用户线程执行完毕之后，不管守护线程是否结束，系统都会自动退出
如果用户线程全部结束了，意味着程序需要完成的业务操作已经结束了，系统可以退出
了。所以当系统只剩下守护进程的时候，java虚拟机会自动退出
设置守护线程，需要在start()方法之前进行

3. (100%)CompletableFuture有了解过吗？----------------------------------
1. Future和Callable接口
   2021年08月15日18:12:27
   Future接口定义了操作 异步任务执行一些方法 ，如获取异步任务的执行结果、取消任务的执行、判断任务是否被取消、判断任务执行是否完毕等。

Callable接口中定义了需要有返回的任务需要实现的方法。

比如主线程让一个子线程去执行任务，子线程可能比较耗时，启动子线程开始执行任务后，
主线程就去做其他事情了，过了一会才去获取子任务的执行结果。
2. FutureTask有什么缺点？有什么替代品?
   FutureTask继承关系

FutureTask存在阻塞

3. CompletableFuture和CompletionStage源码分别介绍
   2021年08月15日19:09:40
   从思想的角度上看：FutureTask升级版本就是CompletableFuture 类似于从i到i++，一个升级版本
   CompletableFuture：
1. 在Java8中，CompletableFuture提供 了非常强大的Future的扩展功能，可以帮助我们简化异步编程的复杂性，并且提供了函数式编程的能力，可以通过回调的方式处理计算结果，也提供了转换和组合CompletableFuture的方法。
2. 它可能代表一个明确完成的Future,也有可能代表一 个完成阶段( CompletionStage )，它支持在计算完成以后触发一 些函数或执行某些动作。
3. 它实现了Future和CompletionStage接口
   CompletionStage：代表异步计算过程中的某一个阶段，一个阶段完成以后可能会触发另外一个阶段，有些类似Linux系统的管道分隔符传参数。

从Java8开始引入了CompletableFuture，它是Future的功能增强版，
可以传入回调对象，当异步任务完成或者发生异常时，自动调用回调对象的回调方法

自己总结：
1. CompletableFuture只是增强类，如果还是用get的方法获取返回值，那么还是会造成阻塞，所以 实现了  implements CompletionStage<T> 这个接口，这样就可以直接用whenComplete方法，就可以解决阻塞问题
2. 因为使用默认线程池导致不能计算完毕，没有返回值问题，这里贴一下代码：
   public static void main(String[] args) throws Exception {
   ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(1, 20, 1L,
   TimeUnit.SECONDS, new LinkedBlockingQueue<>(50), Executors.defaultThreadFactory(),
   new ThreadPoolExecutor.AbortPolicy());
   CompletableFuture<Integer> completableFuture = CompletableFuture.supplyAsync(() -> {
   // 进入异步编排
   try {
   TimeUnit.SECONDS.sleep(2);
   } catch (InterruptedException e) {
   e.printStackTrace();
   }
   return 1;
   // 这里如果不用自己创建的线程池threadPoolExecutor，那么会使用默认的forkxxxpoll线程池，而然默认的forkxxxpool线程是守护线程，
   // 主线程退出，导致守护线程也结束，所以就造成了没有计算出值
   // 解决方案：用自己的线程，因为自己创建的线程池是守护线程
   },threadPoolExecutor).whenComplete((v, e) -> {
   if (e == null) {
   System.out.println("----没有异常进行输出"+v);
   }
   }).exceptionally(e -> {
   e.printStackTrace();
   return null;
   });
   System.out.println("main--------结束");
   threadPoolExecutor.shutdown();
   }
2. join与get的区别对比：其实是一样的，区别就是join不抛出异常



4. Lambda +Stream+链式调用+Java8函数式编程带走
   2021年08月15日21:09:10



4. 说说Java“锁”事----------------------------------
   2021年08月16日22:53:15
1. 你能说说什么是乐观锁，什么是悲观锁吗？

2. sync锁你能说说什么是对象锁，什么是类锁吗？或者说这个锁到底锁的是什么？

3. sync底层的实现知道是什么？
   实现使用的是monitorenter和monitorexit指令
   为什么sync反编译monitorenter与monitorexit是1:2？
   因为如果异常了，要确保释放锁
   如果你在代码里面直接抛了异常 那就是1：1

4. 为什么任何一个对象都可以成为一个锁
   因为所有对象最终都是继承Object呀
5. 在HotSpot虚拟机中，monitor怎么实现的？
   monitor采用ObjectMonitor实现
   C++源码解读
   ObjectMonitor.java→ObjectMonitor.cpp→objectMonitor.hpp
   objectMonitor.hpp
   每个对象天生都带着一个对象监视器

6. 那你了解公平锁与非公平锁吗？
   ReentrantLock就是公平锁与非公平锁
   公平锁就是雨露均沾
   非公平锁缺点就是容易造成锁饥饿，就是abc三个线程，一直被a抢走



6.1 为什么会有公平锁/非公平锁的设计？为什么默认非公平？
因为公平就牺牲了性能，我看了源码，传入true有个三目运算符，会构造公平锁的方法
里面多了一个判断
使用多线程很重要的考量点是线程切换的开销，当采用非公平锁时， 当1个线程请求锁获取同步状态，然后释放同步状态，因为不需要考虑是否还有前驱节点，所以刚释放锁的线程在此刻再次获取同步状态的概率就变得非常大，所以就减少了线程的开销 。
所以我觉得因为这些元素才默认公平
6.2 使⽤公平锁会有什么问题？
公平锁保证了排队的公平性，非公平锁霸气的忽视这个规则，所以就有可能导致排队的长时间在排队，也没有机会获取到锁，
这就是传说中的 “锁饥饿”
6.3 什么时候用公平？什么时候用非公平？
如果为了更高的吞吐量，很显然非公平锁是比较合适的，因为节省很多线程切换时间，吞吐量自然就上去了；
否则那就用公平锁，大家公平使用。
7. 那可重入锁呢？或者说递归锁？
   可重入锁又叫递归锁呀

是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁(前提，锁对象得是同一个对象)，不会因为之前已经获取过还没释放而阻塞。
如果是1个有 synchronized 修饰的递归调用方法， 程序第2次进入被自己阻塞了岂不是天大的笑话，出现了作茧自缚。
所以 Java中ReentrantLock和synchronized都是可重入锁 ，可重入锁的一个优点是可一定程度避免死锁。
"可重入锁"这四个字分开来解释：
可：可以。
重：再次。
入：进入。
锁：同步锁。
进入什么：进入同步域（即同步代码块/方法或显式锁锁定的代码）
一句话：一个线程中的多个流程可以获取同一把锁，持有这把同步锁可以再次进入。自己可以获取自己的内部锁

7.1 可重入锁种类有了解吗？
隐式锁（即synchronized关键字使用的锁）默认是可重入锁
指的是可重复可递归调用的锁，在外层使用锁之后，在内层仍然可以使用，并且不发生死锁，这样的锁就叫做可重入锁。
简单的来说就是： 在一个synchronized修饰的方法或代码块的内部调用本类的其他synchronized修饰的方法或代码块时，是永远可以得到锁的
与可重入锁相反，不可重入锁不可递归调用，递归调用就发生死锁。
同步块：
同步方法：
Synchronized的重入的实现机理
为什么任何一个对象都可以成为一个锁
每个锁对象拥有一个锁计数器和一个指向持有该锁的线程的指针。

当执行monitorenter时，如果目标锁对象的计数器为零，那么说明它没有被其他线程所持有，Java虚拟机会将该锁对象的持有线程设置为当前线程，并且将其计数器加1。

在目标锁对象的计数器不为零的情况下，如果锁对象的持有线程是当前线程，那么 Java 虚拟机可以将其计数器加1，否则需要等待，直至持有线程释放该锁。

当执行monitorexit时，Java虚拟机则需将锁对象的计数器减1。计数器为零代表锁已被释放。
显式锁（即Lock）也有ReentrantLock这样的可重入锁。
那为什么叫显示跟隐式呢？

8. 死锁及排查有了解？

9. 写锁/读锁知道吗？
   写锁(独占锁)/读锁(共享锁)
   源码深度分析见后续第14章

10. 自旋锁SpinLock知道吗？
11. 无锁→独占锁→读写锁→邮戳锁
12. 无锁→偏向锁→轻量锁→重量锁


5. LockSupport与线程中断----------------------------------
   为什么要线程中断？
   JUC、Netty等框架源码大量用了中断协商机制
   5.1 线程中断机制（重点）
1. 什么是线程中断能说说吗？
   线程中断那这个线程就停止了是吗？
   不是 interrupt 方法调用了不会马上中断这个线程 因为是协商中断机制，只是把默认的false标识位置为为true。

首先
一个线程不应该由其他线程来强制中断或停止，而是应该由线程自己自行停止。
所以，Thread.stop, Thread.suspend, Thread.resume 都已经被废弃了。

其次
在Java中没有办法立即停止一条线程，然而停止线程却显得尤为重要，如取消一个耗时操作。
因此，Java提供了一种用于停止线程的机制——中断。

中断只是一种协作机制，Java没有给中断增加任何语法，中断的过程完全需要程序员自己实现。
若要中断一个线程，你需要手动调用该线程的 interrupt 方法， 该方法也仅仅是将线程对象的中断标识设成true ；
接着你需要自己写代码不断地检测当前线程的标识位，如果为true，表示别的线程要求这条线程中断，
此时究竟该做什么需要你自己写代码实现。

每个线程对象中都有一个标识，用于表示线程是否被中断；该标识位为true表示中断，为false表示未中断；
通过调用线程对象的interrupt方法将该线程的标识位设为true；可以在别的线程中调用，也可以在自己的线程中调用。
2. 如何停止、中断一个运行中的线程？？ （延伸）
3. 中断的相关API方法有了解吗？
   interrupt 方法调用了不会马上中断这个线程 因为是协商中断机制，只是把默认的false标识位置为为true。

4. 如何使用中断标识停止线程？
   在需要中断的线程中不断监听中断状态，
   一旦发生中断，就执行相应的中断处理业务逻辑。
   4.1 三种方法：
   通过一个volatile变量实现
   通过AtomicBoolean
   通过Thread类自带的中断api方法实现
   API
   实例方法interrupt()，没有返回值
   源码分析
   实例方法isInterrupted，返回布尔值
   源码分析

4.2 当前线程的中断标识为true，是不是就立刻停止？
不会
具体来说，当对一个线程，调用 interrupt() 时：

①  如果线程处于正常活动状态，那么会将该线程的中断标志设置为 true， 仅此而已 。
被设置中断标志的线程将继续正常运行，不受影响 。所以， interrupt() 并不能真正的中断线程，需要被调用的线程自己进行配合才行。

②  如果线程处于被阻塞状态（例如处于sleep, wait, join 等状态），在别的线程中调用当前线程对象的interrupt方法，
那么线程将立即退出被阻塞状态，并抛出一个InterruptedException异常。
因为抛出异常会把标志位又重置为false，这时候如果还要中断线程，就在调用一下interrupted
小总结：
sleep方法抛出InterruptedException后，中断标识也被清空置为false，我们在
catch没有通过调用th.interrupt() 方法再次将中断标识置为true,这就导致无限循
坏死

4.3 静态方法Thread.interrupted()有了解吗？

1. Thread.interrupted()

2.  都会返回中断状态，两者对比


方法的注释也清晰的表达了“中断状态将会根据传入的ClearInterrupted参数值确定是否重置”。

所以，
静态方法interrupted将       会清除中断状态（传入的参数ClearInterrupted为true）
实例方法isInterrupted则不会（传入的参数ClearInterrupted为false）。
总结
线程中断相关的方法：

interrupt()方法是一个实例方法
它通知目标线程中断，也就是设置目标线程的中断标志位为true，中断标志位表示当前线程已经被中断了。

isInterrupted()方法也是一个实例方法
它判断当前线程是否被中断（通过检查中断标志位）并获取中断标志

Thread类的静态方法interrupted()
返回当前线程的中断状态(boolean类型)且将当前线程的中断状态设为false，此方法调用之后会清除当前线程的中断标志位的状态（将中断标志置为false了），返回当前值并清零置false
5.2 LockSupport是什么
5.3 线程等待唤醒机制

1. LockSupport类中的park等待和unpark唤醒
   通过park()和unpark(thread)方法来实现阻塞和唤醒线程的操作
   LockSupport是用来创建锁和其他同步类的基本线程阻塞原语。

LockSupport类使用了一种名为Permit（许可）的概念来做到 阻塞和唤醒线程 的功能， 每个线程都有一个许可(permit)，
permit只有两个值1和零，默认是零。
可以把许可看成是一种(0,1)信号量（Semaphore），但与 Semaphore 不同的是，许可的累加上限是1。

6. Java内存模型之JMM----------------------------------
   2021年8月21日16:39:49
1. 你知道什么是Java内存模型JMM吗？
   其实就是为了各个线程不能相互对话，必须要在主内存进行读写
   JMM(Java内存模型Java Memory Model，简称JMM)本身是一种抽象的概念并不真实存在它仅仅描述的是一组约定或规范，通过这组规范定义了程序中(尤其是多线程)各个变量的读写访问方式并决定一个线程对共享变量的写入何时以及如何变成对另一个线程可见，关键技术点都是围绕多线程的原子性、可见性和有序性展开的。

原则：
JMM的关键技术点都是围绕多线程的原子性、可见性和有序性展开的

能干嘛？
1 通过JMM来实现线程和主内存之间的抽象关系。
2 屏蔽各个硬件平台和操作系统的内存访问差异以实现让Java程序在各种平台下都能达到一致的内存访问效果。
2. JMM与volatile它们两个之间的关系？(第八章标题有详细解读)
3. JMM有哪些特性or它的三大特性是什么？
   可见性，原子性，有序性
   有序性有啥用呢？
   因为存在指令重排，虽然可以保证串行语义一致，但是没义务保证多线程的语义也一致，既可能产生脏读，简单说 2行以上不相干的代码在执行的时候有可能先执行的不是第一条，不见得就是从上到下的顺序执行，执行顺序会被优化
   大致如下图

4. 为什么要有JMM，它为什么出现？作用和功能是什么？
   读取过程：
   由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存(有些地方称为栈空间)，工作内存是每个线程的私有数据区域，而Java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作(读取赋值等)必须在工作内存中进行，首先要将变量从主内存拷贝到的线程自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，各个线程中的工作内存中存储着主内存中的变量副本拷贝，因此不同的线程间无法访问对方的工作内存，线程间的通信(传值)必须通过主内存来完成，其简要访问过程如下图:

JMM定义了线程和主内存之间的抽象关系
1 线程之间的共享变量存储在主内存中(从硬件角度来说就是内存条)
2 每个线程都有一个私有的本地工作内存，本地工作内存中存储了该线程用来读/写共享变量的副本(从硬件角度来说就是CPU的缓存，比如寄存器、L1、L2、L3缓存等)
小总结 重要
1.   我们定义的所有共享变量都储存在物理主内存中
2.   每个线程都有自己独立的工作内存，里面保存该线程使用到的变量的副本(主内存中该变量的一份拷贝)
3.   线程对共享变量所有的操作都必须先在线程自己的工作内存中进行后写回主内存，不能直接从主内存中读写(不能越级)
4.   不同线程之间也无法直接访问其他线程的工作内存中的变量，线程间变量值的传递需要通过主内存来进行(同级不能相互访问)
5. happens-before先行发生原则你有了解过吗？
   在JMM中，
   如果一个操作执行的结果需要对另一个操作可见性
   或者 代码重排序，那么这两个操作之间必须存在happens-before关系。

5.1 能简单聊几个案例吗？

5.2 先行发生原则说明
如果Java内存模型中所有的有序性都仅靠volatile和synchronized来完成，那么有很多操作都将会变得非常啰嗦，
但是我们在编写Java并发代码的时候并没有察觉到这一点。

我们没有时时、处处、次次，添加volatile和synchronized来完成程序，这是因为Java语言中JMM原则下
有一个“先行发生”(Happens-Before)的原则限制和规矩

这个原则非常重要：  
它是判断数据是否存在竞争，线程是否安全的非常有用的手段。依赖这个原则，我们可以通过几条简单规则一揽子解决并发环境下两个操
作之间是否可能存在冲突的所有问题，而不需要陷入Java内存模型苦涩难懂的底层编译原理之中。
5.3 happens-before总原则
如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见， 而且第一个操作的执行顺序排在第二个操作之前。也就是现有爸爸后又儿子
两个操作之间存在happens-before关系，并不意味着一定要按照happens-before原则制定的顺序来执行。 如果重排序之后的执行结果与按照happens-before关系来执行的结果一致，那么这种重排序并不非法。
举个例子：
值日 周一张三周二李四，假如有事情调换班可以的
1+2+3 = 3+2+1

5.4 happens-before之8条规则
happens-before之8条
次序规则：
一个线程内，按照代码顺序，写在前面的操作先行发生于写在后面的操作；
加深说明
前一个操作的结果可以被后续的操作获取。 讲白点就是前面一个操作把变量X赋值为1，那后面一个操作肯定能知道X已经变成了1。
锁定规则：
一个unLock操作先行发生于后面((这里的“后面”是指时间上的先后))对同一个锁的lock操作；（上一个线程先unLock 后面一个现场才能lock）
volatile变量规则：
对一个volatile变量的写操作先行发生于后面对这个变量的读操作， 前面的写对后面的读是可见的，这里的“后面”同样是指时间上的先后。
传递规则：
如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C；
线程启动规则(Thread Start Rule)：
Thread对象的start()方法先行发生于此线程的每一个动作
线程中断规则(Thread Interruption Rule)：
对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生；
可以通过Thread.interrupted()检测到是否发生中断
线程终止规则(Thread Termination Rule)：
线程中的所有操作都先行发生于对此线程的终止检 测，我们可以通过Thread::join()方法是否结束、 Thread::isAlive()的返回值等手段检测线程是否已经终止执行。
对象终结规则(Finalizer Rule)：
一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始
说人话
对象没有完成初始化之前，是不能调用finalized()方法的
7. volatile与Java内存模型----------------------------------
   2021年8月22日00:05:55
1. 被volatile修改的变量有2大特点
   被volatile修改的变量有2大特点
   特点
   可见性
   有序性排序要求
   volatile的内存语义
   当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值立即刷新回主内存中。
   当读一个volatile变量时，JMM会把该线程对应的本地内存设置为无效，直接从主内存中读取共享变量
   所以volatile的写内存语义是直接刷新到主内存中，读的内存语义是直接从主内存中读取。
2. 内存屏障（重点）
   2.1 什么是内存屏障？
   内存屏障（也称内存栅栏，内存栅障，屏障指令等，是一类同步屏障指令，是CPU或编译器在对内存随机访问的操作中的一个同步点，使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作），避免代码重排序。内存屏障其实就是一种JVM指令，Java内存模型的重排规则会要求Java编译器在生成JVM指令时插入特定的内存屏障指令，通过这些内存屏障指令，volatile实现了Java内存模型中的可见性和有序性，但volatile无法保证原子性。

内存屏障之前的所有写操作都要回写到主内存，
内存屏障之后的所有读操作都能获得内存屏障之前的所有写操作的最新结果(实现了可见性)。

因此重排序时，不允许把内存屏障之后的指令重排序到内存屏障之前。
一句话：对一个 volatile 域的写, happens-before 于任意后续对这个 volatile 域的读，也叫写后读。
2.2 那内存屏障指令有了解吗？
JVM中提供了四类内存屏障指令
一句话
上一章讲解过happens-before先行发生原则，类似接口规范，落地？
落地靠什么？
你凭什么可以保证？你管用吗？
C++源码分析
IDEA工具里面找Unsafe.class
Unsafe.java
Unsafe.cpp
OrderAccess.hpp
orderAccess_linux_x86.inline.hpp
四大屏障分别是什么意思
orderAccess_linux_x86.inline.hpp

volatile保证有序性 - happens-before 之 volatile 变量规则

当第一个操作为volatile读时，不论第二个操作是什么，都不能重排序。这个操作保证了volatile读之后的操作不会被重排到volatile读之前。
当第二个操作为volatile写时，不论第一个操作是什么，都不能重排序。这个操作保证了volatile写之前的操作不会被重排到volatile写之后。
当第一个操作为volatile写时，第二个操作为volatile读时，不能重排。

JMM 就将内存屏障插⼊策略分为 4 种
写：
1.  在每个 volatile 写操作的前⾯插⼊⼀个 StoreStore 屏障
2.  在每个 volatile 写操作的后⾯插⼊⼀个 StoreLoad 屏障
    读：
3.  在每个 volatile 读操作的后⾯插⼊⼀个 LoadLoad 屏障
4.  在每个 volatile 读操作的后⾯插⼊⼀个 LoadStore 屏障


3. volatile特性
   3.1 保证可见性
   说明
   Code
   public class VolatileSeeDemo
   {
   static          boolean flag = true;       //不加volatile，没有可见性
   //static volatile boolean flag = true;       //加了volatile，保证可见性

   public static void main(String[] args)
   {
   new Thread(() -> {
   System.out.println(Thread.currentThread().getName()+"\t come in");
   while (flag)
   {

            }
            System.out.println(Thread.currentThread().getName()+"\t flag被修改为false,退出.....");
        },"t1").start();

        //暂停2秒钟后让main线程修改flag值
        try { TimeUnit.SECONDS.sleep(2); } catch (InterruptedException e) { e.printStackTrace(); }

        flag = false;

        System.out.println("main线程修改完成");
   }
   }
   线程t1中为何看不到被主线程main修改为false的flag的值？

问题可能:
1. 主线程修改了flag之后没有将其刷新到主内存，所以t1线程看不到。
2. 主线程将flag刷新到了主内存，但是t1一直读取的是自己工作内存中flag的值，没有去主内存中更新获取flag最新的值。

我们的诉求：
1.线程中修改了工作内存中的副本之后，立即将其刷新到主内存；
2.工作内存中每次读取共享变量时，都去主内存中重新读取，然后拷贝到工作内存。

解决：
使用volatile修饰共享变量，就可以达到上面的效果，被volatile修改的变量有以下特点：
1. 线程中读取的时候，每次读取都会去主内存中读取共享变量最新的值，然后将其复制到工作内存
2. 线程中修改了工作内存中变量的副本，修改之后会立即刷新到主内存

不加volatile，没有可见性，程序无法停止
加了volatile，保证可见性，程序可以停止

volatile变量的读写过程
Java内存模型中定义的8种工作内存与主内存之间的原子操作
read(读取)→load(加载)→use(使用)→assign(赋值)→store(存储)→write(写入)→lock(锁定)→unlock(解锁)

read: 作用于主内存，将变量的值从主内存传输到工作内存，主内存到工作内存
load: 作用于工作内存，将read从主内存传输的变量值放入工作内存变量副本中，即数据加载
use: 作用于工作内存，将工作内存变量副本的值传递给执行引擎，每当JVM遇到需要该变量的字节码指令时会执行该操作
assign: 作用于工作内存，将从执行引擎接收到的值赋值给工作内存变量，每当JVM遇到一个给变量赋值字节码指令时会执行该操作
store: 作用于工作内存，将赋值完毕的工作变量的值写回给主内存
write: 作用于主内存，将store传输过来的变量值赋值给主内存中的变量
由于上述只能保证单条指令的原子性，针对多条指令的组合性原子保证，没有大面积加锁，所以，JVM提供了另外两个原子指令：
lock: 作用于主内存，将一个变量标记为一个线程独占的状态，只是写时候加锁，就只是锁了写变量的过程。
unlock: 作用于主内存，把一个处于锁定状态的变量释放，然后才能被其他线程占用

3.2 没有原子性
volatile变量的复合操作(如i++)不具有原子性
Code
从i++的字节码角度说明
不保证原子性
读取赋值一个普通变量的情况
既然一修改就是可见，为什么还不能保证原子性？
volatile主要是对其中部分指令做了处理
结论
面试回答
JVM的字节码，i++分成三步，间隙期不同步非原子操作(i++)
3.3 指令禁重排
3.3.1说明与案例
重排序
重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段，有时候会改变程序语句的先后顺序
不存在数据依赖关系，可以重排序；
存在数据依赖关系，禁止重排序
但重排后的指令绝对不能改变原有的串行语义！ 这点在并发设计中必须要重点考虑！

重排序的分类和执行流程

编译器优化的重排序 ：  编译器在不改变单线程串行语义的前提下，可以重新调整指令的执行顺序
指令级并行的重排序 ：  处理器使用指令级并行技术来讲多条指令重叠执行，若不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序
内存系统的重排序 ：  由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是乱序执行

数据依赖性 ： 若两个操作访问同一变量，且这两个操作中有一个为写操作，此时两操作间就存在数据依赖性。

案例 ：
不存在 数据依赖关系，可以重排序===>  重排序OK  。
重排前 	重排后
int a = 1;  //1
int b = 20; //2
int c = a + b; //3 	int b = 20;  //1
int a = 1; //2
int c = a + b; //3
结论：编译器调整了语句的顺序，但是不影响程序的最终结果。 	重排序OK

存在 数据依赖关系 ，禁止重排序 ===>  重排序发生，会导致程序运行结果不同。
编译器和处理器在重排序时，会遵守数据依赖性，不会改变存在依赖关系的两个操作的执行,但不同处理器和不同线程之间的数据性不会被编译器和处理器考虑，其只会作用于单处理器和单线程环境，下面三种情况，只要重排序两个操作的执行顺序，程序的执行结果就会被改变。
3.3.2 volatile的底层实现是通过内存屏障，2次复习
1. volatile有关的禁止指令重排的行为

2.四大屏障的插入情况
1. 在每一个volatile写操作前面插入一个StoreStore屏障
   StoreStore屏障可以保证在volatile写之前，其前面的所有普通写操作都已经刷新到主内存中。
2. 在每一个volatile写操作后面插入一个StoreLoad屏障
   StoreLoad屏障的作用是避免volatile写与后面可能有的volatile读/写操作重排序
3. 在每一个volatile读操作后面插入一个LoadLoad屏障
   LoadLoad屏障用来禁止处理器把上面的volatile读与下面的普通读重排序。
4. 在每一个volatile读操作后面插入一个LoadStore屏障
   LoadStore屏障用来禁止处理器把上面的volatile读与下面的普通写重排序。
   Code说明


4. 如何正确使用volatile

5. 总结

8. CAS---------------------------------------------------------


9. 原子操作类之18罗汉增强----------------------------------
10. 聊聊ThreadLocal
    ThreadLocal为什么不能加static
11. Java对象内存布局和对象头

12. Synchronized与锁升级
13. AbstractQueuedSynchronizer之AQS
14. ReentrantLock、ReentrantReadWriteLock、StampedLock讲解
15. 总结与回顾






























