# 1. 类的加载篇

## 1.1 类的加载过程

### 01 说说类加载分几步?

### 02 过程一: Loading(装载)阶段

**按照Java虚拟机规范，从class文件到加载到内存中的类，到类卸载出内存为止，它的整个生命周期包括**

**如下7个阶段: **

![](https://cdn.nlark.com/yuque/0/2021/png/2075923/1630830471649-e07c5aba-c813-4c71-8e70-5a02fea0738d.png)

**其中:**

**①第一过程 的加载(loading)也称为装载**

**②验证、准备、解析3个部分统称为链接( Linking)**

**从程序中类的使用过程看:**

**这个helloworld只会加载一次吗？只会被同一个类加载器加载一次，类加载有一个命名空间，因为命名空间跟这个类双向绑定，但是可以用别的类加载器在加载一次，实现类的隔离嘛，就是喜欢把这个类加载到不同的场景下，就需要不同的加载器加载同一个类，这一类的类加载器就需要自定义**

![](https://cdn.nlark.com/yuque/0/2021/png/2075923/1630830649225-d8dbb516-589f-4d3d-a8bd-806ab24f4556.png)

**都谁需要加载？**

**在Java中数据类型分为基本数据类型和引用数据类型。基本数据类型由虚拟机预先定义，引用数据类型则需要进行类的加载。**

**过程一:类的装载**

**所谓装载，简而言之就是将Java类的字节码文件加载到机器内存中，并在内存中构建出Java类的原型**类模板**对象。**

**装载完成的操作**

**装载阶段，简言之，查找并加载类的二进制数据，生成Class的实例。**

**在加载类时，Java虚拟机必须完成以下3件事情:**

**通过类的全名，获取类的二进制数据流。**

**解析类的二进制数据流为方法区内的数据结构(Java类模型)**

**创建java.lang. Class类的实例，表示该类型。作为方法区这个类的各种数据的访问入口**

**那什么是类模板呢？**

**类模板对象**

**所谓类模板对象，其实就是Java类在JVM内存中的一个快照，JVM将从字节码文件中解析出的常量池、类字**

**段、类方法等信息存储到类模板中，这样JVM在运行期便能通过类模板而获取Java类中的任意信息，能够**

**对Java类的成员变量进行遍历，也能进行Java方法的调用。**

**反射的机制即基于这一基础。如果JVM没有将Java类的声明信息存储起来，则JVM在运行期也无法反射。**

**类模型的位置**

**加载的类在JVM中创建相应的类结构，类结构会存储在方法区(JDK1.8之前:永久代; JDK1.8及之后叫元空间)。**

**说说二进制流的获取方式**

**对于类的二进制数据流，虚拟机可以通过多种途径产生或获得。( 只要所读取的字节码符合JVM规范即可)**

**虚拟机可能通过文件系统读入一个class后缀的文件(最常见)**

**读入jar、zip等归档数据包，提取类文件。**

**事先存放在数据库中的类的二进制数据**

**使用类似于HTTP之类的协议通过网络进行加载**

**在运行时生成一段Class的二进制信息等**

**在获取到类的二进制信息后，Java虚拟机就会处理这些数据，并最终转为一个java. lang. Class的实例。**

**如果输入数据不是ClassFile的结构，则会抛出ClassFormatError.**

**Class实例的位置**

**类将.class文件加载至元空间后，会在堆中创建- -个Java. lang . Class对象，用来封装类位于方法区内**的数据结构，该Class对象是在加载类的过程中创建的，每个类都对应有一个Class类 型的对象。

**(instanceKlass -- >mirror :Class的实例)**

![](https://cdn.nlark.com/yuque/0/2021/png/2075923/1630831222281-562e8713-5f2c-4c58-b0d6-2801fa2e76f8.png)

![](https://cdn.nlark.com/yuque/0/2021/png/2075923/1630831260748-f3b79479-0e9c-474b-890e-32190e5c83ea.png)

**这里注意 如果Order你给了它一个名，那就多一个栈空间存放**

**外部可以通过访问代表0rder类的Class对象来获取Order的类数据结构。**

**4.再说明**

**Class类的构造方法是私有的，只有JVM能够创建。**

**java. lang. Class实例是访问类型元数据的接口，也是实现反射的关键数据、入口。通过Class类提供的**

**接口，可以获得目标类所关联的. class文件中具体的数据结构:方法、字段等信息。**

**数组类的加载**

**创建数组类的情况稍微有些特殊，因为数组类本身并不是由类加载器负责创建，而是由JVM在运行时根据需要而直接创建的，但数组的元素类型仍然需要依靠类加载器去创建。创建数组类(下述简称A)的过程:**

**1.如果数组的元素类型是引用类型，那么就遵循定义的加载过程递归加载和创建数组A的元素类型;**

**2.JVM使用指定的元素类型和数组维度来创建新的数组类。**

**3.如果数组的元素类型是引用类型，数组类的可访问性就由元素类型的可访问性决定。否则数组类的可访问性将被缺省定义为public。**

**int[] arr**

**String[]arr**

**Object[] arr**

### 03 过程二: Linking(链接)阶段

![](https://cdn.nlark.com/yuque/0/2021/png/2075923/1630842876300-6dcb57c3-5757-4ecc-97df-894b21910c66.png)

#### 环节1:链接阶段之Verification(验证)

#### 环节2:链接阶段之Preparation(准备）

**简言之，为类的静态变量分配内存，并将其初始化为默认值。**

**在这个阶段，虚拟机就会为这个类分配相应的内存空间，并设置默认初始值Java虚拟机为各类型变量默认的初始值如表所示。**

![](https://cdn.nlark.com/yuque/0/2021/png/2075923/1630843104429-564e2d74-b2e3-4c4d-9916-76afc73058ea.png)

**注意** **: Java并不支持boolean类型，对于boolean类型，内部实现是int,由于int的默认值是0,故对应的，boolean的默认值就是false。**

**注意** **:**

**1.这里不包含基本数据类型的字段用static final修饰的情况，因为final在编译的**

**时候就会分配了，准备阶段会显式赋值。**

**2.注意这里不会为实例变量分配初始化，实例变量是会随着对象一起分配到Java堆中。**

**3.在这个阶段并不会像初始化阶段中那样会有初始化或者代码被执行。**

#### 环节3:链接阶段之Resolution(解析)

**简言之，将类、接口、字段和方法的符号引用转为直接引用。**

**1.具体描述:**

**符号引用就是- -些字面量的引用，和虚拟机的内部数据结构和和内存布局无关。比较容易**

**理解的就是在Class类文件中，通过常量池进行了大量的符号引用。但是在程序实际运行**

**时，只有符号引用是不够的，比如当如下println()方法被调用时，系统需要明确知道该**

**方法的位置。**

**举例:输出操作System. out . println()对应的字节码:**

**invokevirtual****(可能会重写)** #24 <java/ io/ PrintStream. println>

![](https://cdn.nlark.com/yuque/0/2021/png/2075923/1630843312448-4f776e0a-5a18-4647-96da-b2abbb8f28b9.png)

**以方法为例，Java虚拟机为每个类都准备了一张方法表，将其所有的方法都列在表中，当需要调用一个类的方法的时候，只要知道这个方法在方法表中的偏移量就可以直接调用该方法。**通过解析操作，符号引用就可以转变为目标方法在类中方法表中的位置，从而使得方法被成功调用**。**

**2.小结:**

**所谓解析就是将符号引用转为直接引用，也就是得到类、字段、方法在内存中的指针或者偏移量。因此，可以说，如果直接引用存在，那么可以肯定系统中存在该类、方法或者字段。但只存在符号引用，不能确定系统中一定存在该结构。**

**不过Java虚拟机规范并没有明确要求解析阶段一定要按照顺序执行。HotSpotVM中，加载、验证、准备和初始化会按照顺序有条不紊地执行，但链接阶段中的解析操作往往会伴随着JVM在执行完初始化之后再执行。**

**3.字符串的复习**

**最后，再来看一下CONSTANT_ String的解析。由于字符串在程序开发中有着重要的作用因此，读者有必要了解一下String在Java虚拟机中的处理。当在Java代码中直接使用字符串常量时，就会在类中出现CONSTANT_ String, 它表示字符串常量，并且会引用一个CONSTANT_ UTF8的常量项。在Java虚拟机内部运行中的常量池中，会维护-张 字符串拘留表(intern)，它会保存所有出现过的字符串常量，并且没有重复项。只要以CONSTANT_ String形式出现的字符串也都会在这张表中。使用String. intern()方法可以得到一个字符串在拘留表中的引用，因为该表中没有重复项，所以任何字面相同的字符串的String。intern()方法返回总是相等的。**

### 04 过程三: Initialization(初始化)阶段(重要)

**初始化阶段，简言之，为类的静态变量赋予正确的初始值。(显式初始化)**

**具体描述**

**类的初始化是类装载的最后-一个阶段。如果前面的步骤都没有问题，那么表示类可以顺利装载到系统中。此时，类才会开始执行Java字节码。(即: 到了初始化阶段，才真正开始执行类中定义的Java 程序代码。初始化阶段的重要工作是执行类的初始化方法:`<clinit>`()方法。）**

**1.该方法仅 能由Java编译器生成并由JVM调用，程序开发者无法自定义一个同名的方法更无法直接在Java程序中调用该方法，虽然该方法也是由字节码指令所组成。**

**2.它是由类静态成员的赋值语句以及static语句块合并产生的。**

**`<clinit>`():只有在給炎的中的static的变量显式或在静态代码块中赋值了了。オ**

**会生成此方法。**

**`<init>`()一 定会出现在Class的method表中。**

#### 1. 子类加载前，先加载父类吗？

**在加载一个类之前，虚拟机总是会试图加载该类的父类，因此父类的`<clinit>`总是在子**

**类`<clinit>`之前被调用。也就是说，父类的static块优先级高于子类。**

**口诀:由父及子，静态先行。**

#### 2. 哪些类不会生成`<clinit>`方法？

**Java编译器并不会为所有的类都产生`<clinit>`()初始化方法。哪些类在编译为字节码后，字节码文件中将不会包含`<clinit>`()方法?**

**●一个类中并没有声明任何的类变量，也没有静态代码块时**

**●一个类中声明类变量，但是没有明确使用类变量的初始化语句以及静态代码块来执行初始化操作时**

**●一个类中 包含static final修饰的基本数据类型的字段，这些类字段初始化语句采用编译时常量表达式**

**代码示例：**

```
public class InitializationTest1 {
    //场景1：对于非静态的字段，不管是否进行了显式赋值，都不会生成<clinit>()方法
    public int num = 1;
    //场景2：静态的字段，没有显式的赋值，不会生成<clinit>()方法
    public static int num1;
    //场景3：比如对于声明为static final的基本数据类型的字段，不管是否进行了显式赋值，都不会生成<clinit>()方法
    public static final int num2 = 1;
}
```

#### 3. 使用static + final修饰的字段的显式赋值的操作，到底是在哪个阶段进行的赋值？

```
 * 一、说明：使用static + final修饰的字段的显式赋值的操作，到底是在哪个阶段进行的赋值？
 * 情况1：在链接阶段的准备环节赋值
 * 情况2：在初始化阶段<clinit>()中赋值
 *
 * 二、结论：
 * 1. 在链接阶段的准备环节赋值的情况：
 * 1）对于基本数据类型的字段来说，如果使用static final修饰，则显式赋值(直接赋值常量，而非调用方法）通常是在链接阶段的准备环节进行
 * 2）对于String来说，如果使用字面量的方式赋值，使用static final修饰的话，则显式赋值通常是在链接阶段的准备环节进行
 *
 * 2. 在初始化阶段<clinit>()中赋值的情况：
 * 排除上述的在准备环节赋值的情况之外的情况。
 *
 *
 *  总结：
 *  使用static + final 修饰的成员变量，称为：全局常量。
 *  什么时候在链接阶段的准备环节：给此全局常量附的值是字面量或常量。不涉及到方法或构造器的调用。
 *  除此之外，都是在初始化环节赋值的。
 *
 */
public class InitializationTest2 {
    public static int a = 1;   //在初始化阶段赋值
    public static final int INT_CONSTANT = 10;   //在链接阶段的准备环节赋值

    public static Integer INTEGER_CONSTANT1 = Integer.valueOf(100); //在初始化阶段赋值
    public static final Integer INTEGER_CONSTANT2 = Integer.valueOf(1000); //在初始化阶段赋值
//
    public static final String s0 = "helloworld0";   //在链接阶段的准备环节赋值
    public static final String s1 = new String("helloworld1"); //在初始化阶段赋值
//
    public static String s2 = "helloworld2";  //在初始化阶段赋值
//
    public static final int NUM1 = new Random().nextInt(10);  //在初始化阶段赋值

    static int a = 9;//在初始化阶段赋值
    static final int b = a; //在初始化阶段赋值

}
```

#### 4.`<clinit>`( )方法的调用会死锁吗？

**会**

**对于`<clinit>`( )方法的调用，也就是类的初始化，虚拟机会在内部确保其多线程环境中的安全性。**

**虚拟机会保证一个类的`<clinit>`( )方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化-一个类，那么只会有一个线程去执行这个类的`<clinit>`()方法，其他线程都需要阻塞等待，直到活动线程执行`<clinit>`()方法完毕。**

**正是因为函数`<clinit>`( )带锁线程安全的，因此，如果在一个类的`<clinit>`( )方法中**

**有耗时很长的操作，就可能造成多个线程阻塞，引发死锁。并且这种死锁是很难发现的，因为看起来它们并没有可用的锁信息。**

**如果之前的线程成功加载了类，则等在队列中的线程就没有机会再执行`<clinit>`()方法了。 那么， 当需要使用这个类时，虚拟机会直接返回给它已经准备好的信息。**

### 05 过程四:类的Using(使用)

**任何一个类型在使用之前都必须经历过完整的加载、链接和初始化3个类加载步骤。一旦一个类型成功经历过这3个步骤之后，便“万事俱备，只欠东风”，就等着开发者使用了。**

**开发人员可以在程序中访问和调用它的静态类成员信息(比如:静态字段、静态方法)，或者使用new关键字为其创建对象实例。**

### 06 过程五:类的Unloading(卸载)

**类、类的加载器、类的实例之间的引用关系**

**在类加载器的内部实现中，用一个Java集合来存放所加载类的引用。另一方面，一个Class对 象总是会引用它的类加载器，调用Class对 象的getClassLoader()方法，就能获得它的类加载器。由此可见，代表某个类的Class实例与其类的加载器之间为双向关联关系。**

**一个类的实例总是引用代表这个类的Class对象。在0bject类中定义了getClass()方法，这个方法返回代表对象所属类的Class对象的引用。此外，所有的Java类都有一个静态属性class,它引用代表这个类的Class对象。**

![](https://cdn.nlark.com/yuque/0/2021/png/2075923/1630850259700-a1c69dc1-5d7c-4d29-9bf6-a68d88560a97.png)

**loader1变量和obj变量间接引用代表Sample类的Class对象，而objClass变量则直接引用它。**

**如果程序运行过程中，将上图左侧三个引用变量都置为null,此时Sample对 象结束生命周期，MyClassLoader对象结束生命周期，代表Sample类的Class对象也结束生命周期，Sample类在方法区内的二进制数据被卸载。**

#### 3. **类卸载在实际生产中的情况如何?**

**类的卸载**

**(1)启动类加载器加载的类型在整个运行期间是不可能被卸载的(jvm和jls规范)**

**(2)被系统类加载器和扩展类加载器加载的类型在运行期间不太可能被卸载，因为系统类加载器实例或者扩展类的实例基本上在整个运行期间总能直接或者间接的访问的到，其达到unreachable的可能性极小。**

**(3) 被开发者自定义的类加载器实例加载的类型只有在很简单的上下文环境中才能被卸载，而且一般还要借助于强制调用虚拟机的垃圾收集功能才可以做到。可以预想，稍微复杂点的应用场景中(比如:很多时候用户在开发自定义类加载器实例的时候采用缓存的策略以提高系统性能)，被加载的类型在运行期间也是几乎不太可能被卸载的(至少卸载的时间是不确定的)。**

**综合以上三点，一个已经加载的类型被卸载的几率很小至少被卸载的时间是不确定的。同时我们可以看的出来，开发者在开发代码时候，不应该对虚拟机的类型卸载做任何假设的前提下，来实现系统中的特定功能。**

#### 4. 方法区的垃圾回收

**方法区的垃圾收集主要回收两部分内容:出量池中废弃的常量和不再使用的类型。**

**HotSpot虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收。**

**判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件:**

**1.该类所有的实例都已经被回收。也就是Java堆中不存在该类及其任何派生子类的实例。**

**2.加载该类的类加载器已经被回收。这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。**

**3.该类对应的java. lang. Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。**

**Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。**

## 1.2 类的加载器

**作用**

**类加载器是JVM执行类加载机制的前提。**

**ClassLoader的作用:**

**ClassLoader是Java的核心组件，所有的Class都是由ClassLoader进行加载的，**

**ClassLoader负责通过各种方式将Class信息的二进制数据流读入JVM内部，转换为一个与目标类对应的java. lang. Class对象实例。然后交给Java虚拟机进行链接、初始化等操作。**

**因此，ClassLoader在 整个装载阶段，只能影响到类的加载，而无法通过ClassLoader去改变类的链接和初始化行为。至于它是否可以运行，则由Execution Engine决定。**

### 1. 类的加载分类:显式加载vs隐式加载

**class文件的显式加载与隐式加载的方式是指JVM加载class文件到内存的方式。**

**显式加载**:指的是在代码中通过调用ClassLoader加载class对象，如直接使用

**Class. forName ( name )或this. getClass(). getClassLoader( ). loadClass( )加载class对象。**

**隐式加载**:则是不直接在代码中调用ClassLoader的方法加载class对象，而是通过虚拟机自动加载到内存中，如在加载某个类的class文件时，该类的class文件中引用了另外一个类的对象，此时额外引用的类将通过JVM自动加载到内存中。

**在日常开发以上两种方式一般会混合使用。**

### 2. 类加载机制的必要性

**一般情况下，Java开发人员并不需要在程序中显式地使用类加载器，但是了解类加载器的加**

**载机制却显得至关重要。从以下几个方面说:**

**●避免在开发中遇到java. lang. ClassNotFoundException异常或**

**java.lang. NoClassDefFoundError异常时，手足无措。只有了解类加载器的加载机制才能够在出现异常的时候快速地根据错误异常日志定位问题和解决问题**

**●需要支持类的动态加载或需要对编译后的字节码文件进行加解密操作时，就需要与类加载器打交道了。**

**●开发人员可以在程序中编写自定义类加载器来重新定义类的加载规则，以便实现一些自定义的处理逻辑。(tomcat加载器)**

### 3. 加载的类是唯一的吗？

**不唯一 必须同一个包底下还得同一个加载器 才是相等 不然别的加载器加载同一个类肯定不是唯一**

**对于任意一个类，都需要由加载它的类加载器和这个类本身一同确认其在Java虚拟机中的唯一性。每一个类加载器，都拥有一个独立的类名称空间:比较两个类是否相等，只有在这两个类是由同一个类加载器加载的前提下才有意义。否则，即使这两个类源自同一个Class文件，被同一个虚拟机加载，只要加载他们的类加载器不同，那这两个类就必定不相等。**

**2.命名空间**

**●每个类加载器都有自己的命名空间，命名空间由该加载器及所有的父加载器所加载的类组成**

**●在同一命名空间中，不会出现类的完整名字(包括类的包名)相同的两个类**

**●在不同的命名空间中，有可能会出现类的完整名字(包括类的包名)相同的两个类**

**在大型应用中，我们往往借助这一-特性，来运行同一个类的不同版本。**

### 4.类加载机制的三个基本特征

**通常类加载机制有三个基本特征:**

**1.双亲委派模型。但不是所有类加载都遵守这个模型，有的时候，启动类加载器所加载的类型，是可能要加载用户代码的，比如JDK内部的ServiceProvider/ServiceLoader机制，用户可以在标准API框架上，提供自己的实现，JDK也需要提供些默认的参考实现。例如，Java 中JNDI、JDBC、文件系统、Cipher等很多方面，都是利用的这种机制，这种情况就不会用双亲委派模型去加载，而是利用所谓的上下文加载器。**

**2.可见性。子类加载器可以访问父加载器加载的类型，但是反过来是不允许的。不然，因为缺少必要的隔离，我们就没有办法利用类加载器去实现容器的逻辑。**

**3.单一性。由于父加载器的类型对于子加载器是可见的，所以父加载器中加载过的类型，就不会在子加载器中重复加载。但是注意，类加载器“邻居”间，同一类型仍然可以被加载**

**多次，因为互相并不可见。**

## 1.3 类的加载器分类与测试

### 1. 类加载器分几种？

**JVM支持两种类型的类加载器，分别为引导类加载器( Bootstrap ClassLoader) (由C++写的)和自定义类加载器(User-Defined ClassLoader)**

**从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这么定义，而是将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器。**

**无论类加载器的类型如何划分，在程序中我们最常见的类加载器结构主要是如下情况:**

![](https://cdn.nlark.com/yuque/0/2021/png/2075923/1630853393835-2f465724-8370-441a-8bdb-7e1c92c1f4ed.png)

### 2. 子父类加载器的关系?

### 3. 具体类的加载器介绍

**启动类**加载器(引导类加载器，Bootstrap ClassLoader)

**●这个类加载使用C/C++语言实现的，嵌套在JVM内部。**

**●它用来加载Java的核心库(JAVA_ HOME/jre/ lib/rt. jar或sun. boot . class . path路径下的内容)。用于提供JVM自身需要的类。**

**并不继承自java. lang. ClassLoader,没有父加载器。出于安全考虑，Bootstrap启 动类加载器只加载包名为java、javax、sun等开头的类**

**●加载扩展类和应用程序类加载器，并指定为他们的父类加载器。**

**扩展类加载器( Extension ClassLoader)**

**●Java语言编写，由sun. misc. Launcher$ExtClassLoader实现。**

**●继承于ClassLoader类**

**●父类加载器为启动类加载器**

**●从java. ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的**

**jre/1ib/ext子目录下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。**

**应用程序类加载器(系统类加载器，AppClassLoader )**

**●java语 言编写，由sun. misc. Launcher$AppClassLoader实现**

**继承于ClassLoader类**

**●父类加载器为扩展类加载器**

**●它负责加载环境变量classpath或系统属性java.class.path 指定路径下的类库**

**应用程序中的类加载器默认是系统类加载器。它是用户自定义类加载器的默认父加载器通过ClassLoader的getSystemClass Loader( )方法可以获取到该类加载器**

**用户自定义类加载器**

**●在Java的 日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的。在必要时，我们还可以自定义类加载器，来定制类的加载方式。**

**体现Java语言强大生命力和巨大魅力的关键因素之一便是,Java开发 者可以自定义类加载器来实现类库的动态加载，加载源可以是本地的JAR包，也可以是网络上的远程资源。**

**●通过类加载器可以实现非常绝妙的插件机制，这方面的实际应用案例举不胜举。例如，著名的OSGI组件框架，再如Eclipse的插件机制。类加载器为应用程序提供了一种动态增加新功能的机制，这种机制无须重新打包发布应用程序就能实现。**

**●同时，自定义加载器能够实现应用隔离，例如Tomcat, Spring 等中间件和组件框架都在内部实现了自定义的加载器，并通过自定义加载器隔离不同的组件模块。这种机制比C/C++程序要好太多，想不修改C/C++程序就能为其新增功能，几乎是不可能的，仅仅一个兼容性便能阻挡住所有美好的设想。**

**所有用户自定义类加载器通常需要继承于抽象类java.lang. ClassLoader.**

### 4. 测试不同的类加载器

**测试不同的类加载器**

**每个Class对象都会包含一个定义它的ClassLoader的一个引用。**

**获取ClassLoader的途径**

**获得当前类的ClassLoader**

**clazz. getClassLoader( )**

**获得当前线程上下文的ClassLoader**

**Thread. currentThread(). getContextClassLoader()**

**获得系统的ClassLoader**

**ClassLoader. getSystemClassLoader( )**

**说明:**

**站在程序的角度看，引导类加载器与另外两种类加载器( 系统类加载器和扩展类加载器)并不是同一个层次意义上的加载器，引导类加载器是使用C++语言编写而成的，而另外两种类加载器则是使用Java语言编写而成的。由于引导类加载器压根儿就不是一个Java类， 因此在Java程序中只能打印出空值。**

## 1.4 ClassLoader源码剖析

## 1.5 自定义类的加载器

## 1.6 相关机制

## 面试题

### 1. JVM中类加载机制，类加载过程，什么是双亲委派模型? ( 腾讯)

### 2. 描述一下JVM加载Class文件的原理机制? (国美)

![](https://cdn.nlark.com/yuque/0/2021/png/2075923/1630830398200-7e086523-1006-4749-85a5-038975c5af1a.png)

### 3. 类加载的时机(百度)

**Class的forName( "Java. lang . String" )和Class的getClassLoader( )的loadClass ("Java.lang. String")有什么区别?(百度)**

**A: ****这个forName( "Java. lang . String" )会执行到类的初始化过程**

**但是loadClass只会执行到loading(装载阶段)**

**哪些情况会触发类的加载?(京东)**

**主动使用的情况**

**。Java虚拟机规定，一-个类或接口在初次使用前，必须要进行初始化。这里指的“使用”，是指主动使用。**

**主动使用只有下列几种情况: ( 即:如果出现如下的情况，则会对类进行初始化操作。而初始化操作之前的加载、验证、准备已经完成。)**

**1.当创建一个类的实例时，比如使用new关键字，或者通过反射、克隆、反序列化。**

**2.当调用类的静态方法时，即当使用了字节码invokestatic指令。**

**3.当使用类、接口的静态字段时(final修饰特殊考虑)，比如，使用getstatic或者**

**putstatic指令。**

**4. 当使用java. lang. reflect包中的方法反射类的方法时。比如:Class . forName(" com. atguigu. java.Test")**

**5.当初始化子类时，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化**

**6.如果一个接口定义了default方法， 那么直接实现或者间接实现该接口的类的初始化，该接口要在其之前被初始化。**

**7. 当虚拟机启动时，用户需要指定一个要执行的主类(包含main()方法的那个类)，虚拟机会先初始化这个主类。**

**被动使用的情况**

**除了以上的情况属于主动使用，其他的情况均属于被动使用。被动使用不会引起类的初始化。**

**也就是说:并不是在代码中出现的类，就一定会被加载或者初始化。如果不符合主动使用的条件，类就不会初始化。**

**1.当访问一个静态字段时，只有真正声明这个字段的类才会被初始化。**

**当通过子类引用父类的静态变量， 不会导致子类初始化**

**2.通过数组定义类引用，不会触发此类的初始化**

**3.引用常量不会触发此类或接口的初始化。因为常量在链接阶段就已经被显式赋值了。**

**4.调用ClassLoader类的loadClass()方法加载-一个类，并不是对类的主动使用，不会导致类的初始化。被动的使用，意味着不需要执行初始化环节，意味着没有`<clinit>`( )的调用。**

### 4. 什么是类加载器，类加载器有哪些? (苏宁)

**简单说说你了解的类加载器(拼多多)**

**类加载器都有哪些?(百度)**

**类加载器有哪些?(腾讯)**

**什么是类加载器，类加载器有哪些? (字节跳动)**

### 5. 深入分析ClassLoader (蚂蚁金服)


**方法返回地址**

**●存放调用该方法的pc寄存器的值。**

**一个方法的结束，有两种方式:**

**●正常执行完成**

**出现未处理的异常，非正常退出**

**●无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，调用者的**

**pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址[而通过异常退出的，返回**

**地址是要通过异常表来确定，栈帧中--般不会保存这部分信息。**

**当一个方法开始执行后，只有两种方式可以退出这个方法:**

**1、执行引擎遇到任意一个方法返回的字节码指令(return)，会有返回值传递给上层的方法调用者**

**，简称正常完成出口;**

**●一个方法在正常调用完成之后究竟需要使用哪一-个返回指令还需要根据方法返回值的实际数据类型**

**而定。**

## 堆

### 1. 概述

**●一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域。**

**●Java堆区在JVM启动的时候即被创建，其空间大小也就确定了。是JVM管理的最大一块内存空间。**

**●堆内存的大小是可以调节的。**

**●《Java虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。**

**●堆，是GC ( Garbage Collection, 垃圾收集器)执行垃圾回收的重点区域。**

**●****在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。**

**●《Java虚拟机规范》中对Java堆的描述是:所有的对象实例以及数组都应当在运行时分配在堆上。(The heap is the run-time data area from which memory for all class instances and arrays is allocated )数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。**

**●我要说的是:“几乎”所有的对象实例都在这里分配内存。--从实际使用角度看的。**

**搞清楚一个概念****栈上分配**

**所有的线程都共享Java堆吗？**

**所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区( Thread Local**

**Allocation Buffer, TLAB).**

### 2. 堆的内部结构

![](https://cdn.nlark.com/yuque/0/2021/png/2075923/1630938533246-b14648ba-2d03-46b9-a3da-40e883937b98.png)

![](https://cdn.nlark.com/yuque/0/2021/png/2075923/1630938566374-f921dc8f-de9b-4836-ae05-7a8a80c3406c.png)

#### 1. 年轻代与老年代

**存储在JVM中的Java对象可以被划分为两类:**

**一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速**

**●另外一-类对象的生命周期却非常长，在某些极端的情况下还能够与JVM的生命周期保持一致。**

**●Java堆区进一步细分的话，可以划分为年轻代( YoungGen)和老年代( 0ldGen)**

**●其中年轻代又可以划分为Eden空间、Survivor0空 间和Survivor1空间(有时也叫做from区、to区)**

![](https://cdn.nlark.com/yuque/0/2021/png/2075923/1630938649771-71a61fbb-ad91-4ae3-8519-b2ab92c9c2f1.png)

1. **几乎所有的Java对象都是在Eden区被new出来的。**
2. **绝大部分的Java对象的销毁都在新生代进行了。**
3. **IBM公司的专门研究表明，新生代中80%的对象都是“朝生夕死”的。**

### 3. **如何设置堆内存大小?**

#### 1. 如何设置堆内存大小?

**●Java堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，大家可以**

**通过选项”-Xmx”和”-Xms”来进行设置。**

**●-Xms”用于表示堆区的起始内存，等价于-XX:InitialHeapSize**

**●“-Xmx”则用于表示堆区的最大内存，等价于-XX:MaxHeapSize**

**,一旦堆区中的内存大小超过“-Xmx”所指定的最大内存时，将会抛出**

**OutOfMemoryError异常。**

**通常会将-Xms 和-Xmx两个参数配置相同的值，其目的是为了能够在java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能。**

**●heap默认最大值计算方式:如果物理内存少于192M,那么heap最大值为物理内存的一半。如果物理内存大于等于1G, 那么heap的最大值为物理内存的1/4。**

**●heap默认最小值计算方式:最少不得少于8M，如果物理内存大于等于1G,那么默认值为物理内存的1/64，即1024/64=16M。最小堆内存在jvm启动的时候就会被初始化。**

#### 2. 如何设置新生代与老年代比例?

![](https://cdn.nlark.com/yuque/0/2021/png/2075923/1630939266963-d74e4b4d-9f94-4c5f-89a7-ba40425f3ffc.png)

#### 3. 如何设置Eden、幸存者区比例?

**在HotSpot中， Eden空间和另外两个Survivor空间缺省所占的比例是8:1:1**

**当然开发人员可以通过选项“-XX:SurvivorRatio"调整这个空间比例。比如**

**- XX: SurvivorRatio=8**

### 4. 对象分配金句

**对象分配金句**

**为新对象分配内存是一件非常严谨和复杂的任务，JVM的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑GC执行完内存回收后是否会在内存空间中产生内存碎片。**

**金句:, 针对幸存者s0,s1区的总结:复制之后有交换，谁空谁是to.**

**●关于垃圾回收:**

**频繁在新生区收集**

**很少在养老区收集**

**几乎不在永久区/元空间收集**

#### 1. 过程

**过程剖析**

**1.new的对象先放伊甸园区。此区有大小限制。**

**2.当伊甸园的空间填满时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收(MinorGC/YGC)，将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区**

**3.然后将伊甸园中的剩余对象移动到幸存者0区。**

**4.如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区的，如果没有回收，就会放到**

**幸存者1区。**

**5.如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区。**

**6.啥时候能去养老区呢?可以设置次数。默认是15次。**

**●可以设置参数: - XX: MaxTenuringThreshold=`<N>`设置对象晋升老年代的年龄阈值**

**7.在养老区，相对悠闲。当养老区内存不足时，再次触发GC: Major GC，进行养老区的内存清理。**

**8.若养老区执行了Major GC之后发现依然无法进行对象的保存，就会产生00M异常java. lang. OutOfMemoryError: Java heap space**

#### 2.  **分配策略**

**内存分配策略(或对象提升(promotion)规则):**

**如果对象在Eden出生并经过第一次MinorGC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并将对象年龄设为1。对象在Survivor区中每熬过-次MinorGC，年龄就增加1岁，当它的年龄增加到-定程度 (默认为15 岁，其实每 个JVM、每个GC都有所不同)时，就会被晋升到老年代中。**

#### 3. 内存分配原则

**针对不同年龄段的对象分配原则如下所示:**

**优先分配到Eden**

**●大对象直接分配到老年代 I**

**●尽量避免程序中出现过多的大对象**

**●长期存活的对象分配到老年代**

**动态对象年龄判断**

**●如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年**

**龄大于或等于该年龄的对象可以直接进入老年代，无须等到**

**MaxTenuringThreshold中要求的年龄。**

**●空间分配担保**

**●XX: HandlePromotionFailure**

#### 4. 空间分配担保 -XX:HandlePromotionFailure

**在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的**

**总空间，**

**●如果大于，则此次Minor GC是安全的**

**●如果小于，则虚拟机会查看-XX:HandlePromotionFailure设置值是否允许担保失败如果HandlePromotionFailure=true,那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小，如果大于，则尝试进行一-次Minor GC，但这次Minor GC依然是有风险的;如果小于或者HandlePromotionFailure=false,则改为进行一次Full GC。**

**在JDK 6 Update 24之后，HandlePromotionFailure 参数不会再影响到虚拟机的空间分配**

**担保策略，观察OpenJDK 中的源码变化，虽然源码中还定义了HandlePromot ionFailure参数，但是在代码中已经不会再使用它。JDK 6 Update 24之 后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则将进行Fu1lGC。**

### 5. 解释MinorGC、 MajorGC、FullGC

#### 1. 概述

**JVM在进行GC时，并非每次都对上面三个内存(新生代、老年代;方法区)区域一起回收的，大**

**部分时候回收的都是指新生代。**

**针对HotSpot VM的实现，它里面的GC按照回收区域又分为两大种类型:**

**●一种是部分收集(Partial GC)**

**●一种是整堆收集(Full GC)**

**●部分收集:不是完整收集整个Java堆的垃圾收集。其中又分为:**

**●新生代收集(Minor GC / Young GC) :只是新生代(Eden\S0,S1)的垃圾收集**

**●老年代收集(Major GC / 0ld GC) :只是老年代的垃圾收集。**

**●目前，只有CMS GC会有单独收集老年代的行为。**

**注意，很多时候Major GC会和Full GC混淆使用，需要具体分辨是老年代回收**

**还是整堆回收。**

**●混合收集(Mixed GC): 收集整个新生代以及部分老年代的垃圾收集。**

**目前，只有G1 GC会有这种行为**

**●整堆收集(Full GC):收集整个java堆和方法区的垃圾收集。**

#### 2. **年轻代GC (Minor GC) 触发机制:**

**●当年轻代空间不足时，就会触发Minor GC。这里的年轻代满指的是Eden区满，**

**Survivor满不会引发GC。( 每次Minor GC会清理年轻代的内存。)**

**●因为Java 对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收**

**速度也比较快。这一定义既清晰又易于理解。**

**●Minor GC会引发STW，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行**

![](https://cdn.nlark.com/yuque/0/2021/png/2075923/1630940380966-9b04fc6b-7a80-41d7-af73-c4b1f26b93e9.png)

#### 3. **MajorGC触发机制**

**老年代GC (Major GC/Full GC) 触发机制:**

**●指发生在老年代的GC，对象从老年代消失时，我们说“Major GC” 或“Full GC”发生**

**●出现了Major GC，经常会伴随至少-次的Minor GC (但非绝对的， 在Parallel**

**Scavenge收集器的收集策略里就有直接进行MajorGC的策略选择过程)。**

**●也就是在老年代空间不足时，会先尝试触发Minor GC。 如果之后空间还不足，则触发Major GC**

**●Major GC的速度一般会比Minor GC慢10倍以上，STW的时间更长。**

**●如果Major GC后，内存还不足，就报OOM了。**

#### 4. FulIGC触发机制

**触发Full GC执行的情况有如下五种:**

**(1)调用System.gc()时，系统建议执行Full GC，但是不必然执行**

**(2)老年代空间不足**

**(3)方法区空间不足**

**(4)通过Minor GC后进入老年代的平均大小大于老年代的可用内存**

**(5)由Eden区、survivor space0 (From Space) 区向survivor space1 (To Space)**

**区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小**

**说明:**** full gc是开发或调优中尽量要避免的。这样暂时时间会短一些。**

**在默认情况下，通过System. gc( )或者Runtime . getRuntime().gc()的调用，会显式触发Full GC，同时对老年代和新生代进行回收，尝试释放被丢弃对象占用的内存。**

**然而System. gc()调用附带一个免责声明，无法保证对垃圾收集器的调用。**

**JVM实现者可以通过System. gc()调用来决定JVM的GC行为。而一般情况下，垃圾回收应该是自动进行的，无须手动触发，否则就太过于麻烦了。在一些特殊情况 下，如我们正在编写一个性能基准，我们可以在运行之间调用System.gc()。**

### 6. OOM如何解决

**O0M如何解决**

**1、要解决00M异常或heap space的异常， 般的手段 是首先通过内存映像分析工具 (如Eclipse Memory Analyzer) 对dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏(Memory Leak) 还是内存溢出(Memory Overflow) 。**

**2、如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots 的引用链。于是就能找到泄漏对象是通过怎样的路径与GCRoots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息，以及GC Roots 引用链的信息，就可以比较准确地定位出泄漏代码的位置。**

**3、如果不存在内存泄漏，换句话说就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数(-Xmx与-Xms) ，与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。**

### 7. 堆空间分代思想

**经研究，不同对象的生命周期不同。70%-99%的对象是临时对象。**

**●新生代:有Eden、 两块大小相同的Survivor(又称为from/to, s0/s1)构成， to总**

**为空。**

**●老年代:存放新生代中经历多次GC仍然存活的对象。**

**为什么需要把Java堆分代?不分代就不能正常工作了吗? **

**其实不分代完全可以，分代的唯一 理由就是优化GC性能。如果没有分代，那所有的对象都在一块，就如同把一一个学校的人都关在一一个教室。GC的时候要找到哪些对象没用，这样就会对堆的所有区域进行扫描。而很多对象都是朝生夕死的，如果分代的话，把新创建的对象放到某一地方，当GC的时候先把这块存储“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。**

### 8. 快速分配策略: TLAB

#### 1. 为什么有TLAB (Thread Local Allocation Buffer) ?

**堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据**

**●由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的**

**●为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。**

**所以，多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为快速分配策略。**

#### 2. 什么是TLAB?

**●从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，JVM为每个线程分配了一个**

**私有缓存区域，它包含在Eden空间内。**

**●据我所知所有OpenJDK衍生出来的JVM都提供了TLAB的设计。**

![](https://cdn.nlark.com/yuque/0/2021/png/2075923/1630940851722-466de84e-c4da-4d51-8fef-34b78e80433f.png)

#### 3. TLAB的再说明:

**尽管不是所有的对象实例都能够在TLAB中成功分配内存，但JVM确实是将TLAB作为内存分配的首选。**

**在程序中，开发人员可以通过选项“-XX:+/-UseTLAB”设置是否开启TLAB空间。**

**默认情况下，TLAB空间的内存非常小，仅占有整个Eden空间的1%，当然我们可以通过选项“-XX: TLABWasteTargetPercent”设置TLAK空间所占用Eden空间的百分比大小。**

**●-旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在Eden空间中分配内存。**

![](https://cdn.nlark.com/yuque/0/2021/png/2075923/1630940912760-47297452-a94c-42bf-ac8a-0e76c9604fdc.png)

## 对象内存布局

### 1. 你又几种方式创建线程

**new  xxx**

**变形1: Xxx的静态方法**

**变形2: XxxBuilder/XxxFactory的静态方法**

**Class的newInstance():反射的方式，只能调用空参的构造器，权限必须是public**

**Constructor的newInstance(xx):反射的方式，可以调用空参、带参的构造器，权限没有要求，实用性更，**

**使用clone():不调用任何构造器，当前类需要实现Cloneable接口，实现clone()， 默认浅拷贝**

**使用反序列化:从文件中、数据库中、网络中获取一个对象的二进制流，反序列化为内存中的对象**

**第三方库Objenesis,利用了asm字节码技术，动态生成Constructor对象国**

### 2. 创建对象的步骤

#### 2.1 从字节码角度看待对象创建过程

![](https://cdn.nlark.com/yuque/0/2021/png/2075923/1631020561929-44c7242e-ede9-45d7-94aa-902e33b53a02.png)

#### 2.2 对象的访问定位

**句柄访问**

![](https://cdn.nlark.com/yuque/0/2021/png/2075923/1631021423329-92b2c2c5-c5a7-4c1b-9632-fb885b87c9b9.png)

**直接使用指针访问**

**HotSpot使用哪种方式的呢?**

**直接使用指针访问**

## 面试题

### 1. 问题一: 栈溢出的情况?

**栈溢出:Stack0verflowError;**

**举个简单的例子:在main方法中调用main方法，就会不断压栈执行，直到栈溢出;**

**栈的大小可以是固定大小的，也可以是动态变化(动态扩展)的。**

**如果是固定的，可以通过-Xss设置栈的大小;**

**如果是动态变化的，当栈大小到达了整个内存空间不足了，就是抛出OutOfMemory异常(java.lang. OutOfMemoryError)**

### 2. 问题二: 调整栈大小，就能保证不出现溢出吗?

**不能。因为调整栈大小，只会减少出现溢出的可能，栈大小不是可以无限扩大的，所以不能保证不出现溢出**

### 3. 问题三:分配的栈内存越大越好吗?

**不是，因为增加栈大小，会造成每个线程的栈都变的很大，使得一定的栈空间下，能创建的线程数量会变小**

### 4. 问题四:垃圾回收是否会涉及到虚拟机栈?

**不会;垃圾回收只会涉及到方法区和堆中，方法区和堆也会存在溢出的可能;**

**程序计数器，只记录运行下一行的地址，不存在溢出和垃圾回收;**

**虚拟机栈和本地方法栈，都是只涉及压栈和出栈，可能存在栈溢出，不存在垃圾回收。**

### 5. 问题五:方法中定义的局部变量是否线程安全?

### 6. Java 堆的结构是什么样子的? (猎聘)

**JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和**

**Survivor (字节跳动)**

**堆里面的分区: Eden, survival (from+ to)，老年代，各自的特点。 (京东-物流**

**堆的结构?为什么两个survivor区?**

**(蚂蚁金服)**

**Eden和Survior的比例分配 (蚂蚁金服)**

**JVM内存分区，为什么要有新生代和老年代(小米)**

**JVM的内存结构，Eden和Survivor比例。 (京东)**

**JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和**

**Survivor. (京东)**

**JVM内存分区，为什么要有新生代和老年代?**

**(美团)**

**JVM的内存结构，Eden和Survivor比例。 (京东)**

### 7. 什么时候对象会进入老年代? (渣打银行)

**什么时候对象会进入老年代? ( 顺丰)**

**问什么幸存者区15次进入老年区，懂原理吗? (58)**

**JVM的伊甸园区，from区， to区的比例是否可调? ( 花旗银行)**

**JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代(字节跳动)**

**什么时候对象会进入老年代? ( 字节跳动)**

**对象在堆内存创建的生命周期(蚂蚁金服)**

**重点讲讲对象如何晋升到老年代，几种主要的JVM参数( 蚂蚁金服)**

**新生代和老年代的内存回收策略(蚂蚁金服)**

**什么时候对象可以被收回?(蚂蚁金服)**

### 8. 堆大小通过什么参数设置?(阿里)

**初始堆大小和最大堆大小一样，问这样有什么好处?**

**(亚信)**

**JVM中最大堆大小有没有限制? (阿里)**

### 9. **什么是空间分配担保策略? (渣打银行)**

**什么是空间分配担保策略? (顺丰)**

**什么是空间分配担保策略? (腾讯、百度)**

### 10. Minor GC与Full GC分别在什么时候发生? ( 腾讯)

**老年代的垃圾回收机制什么时候触发，自动触发的阈值是多少(蚂蚁金服)**

**新生代的垃圾回收什么时候触发( 蚂蚁金服)**

**简述Java内存分配与回收策略以及MinorGC和MajorGC(国美)**

**什么时候发生Full GC (58)**

**简述Java内存分配与回收策略以及Minor GC和Major GC ( 百度)**

**JVM垃圾回收机制，何时触发Minor GC等操作( 蚂蚁金服)**

**JVM的一次完整的GC流程(从ygc到fgc)是怎样的(蚂蚁金服)**

**描述JVM中一次full gc过程(腾讯)**

**什么情况下触发垃圾回收? (阿里)**

**新生代的垃圾回收什么时候触发(花旗银行)**

**老年代的垃圾回收机制什么时候触发，自动触发的阈值是多少(花旗银行)**



**方法返回地址**

**●存放调用该方法的pc寄存器的值。**

**一个方法的结束，有两种方式:**

**●正常执行完成**

**出现未处理的异常，非正常退出**

**●无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，调用者的**

**pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址[而通过异常退出的，返回**

**地址是要通过异常表来确定，栈帧中--般不会保存这部分信息。**

**当一个方法开始执行后，只有两种方式可以退出这个方法:**

**1、执行引擎遇到任意一个方法返回的字节码指令(return)，会有返回值传递给上层的方法调用者**

**，简称正常完成出口;**

**●一个方法在正常调用完成之后究竟需要使用哪一-个返回指令还需要根据方法返回值的实际数据类型**

**而定。**

## 堆

### 1. 概述

**●一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域。**

**●Java堆区在JVM启动的时候即被创建，其空间大小也就确定了。是JVM管理的最大一块内存空间。**

**●堆内存的大小是可以调节的。**

**●《Java虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。**

**●堆，是GC ( Garbage Collection, 垃圾收集器)执行垃圾回收的重点区域。**

**●****在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。**

**●《Java虚拟机规范》中对Java堆的描述是:所有的对象实例以及数组都应当在运行时分配在堆上。(The heap is the run-time data area from which memory for all class instances and arrays is allocated )数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。**

**●我要说的是:“几乎”所有的对象实例都在这里分配内存。--从实际使用角度看的。**

**搞清楚一个概念****栈上分配**

**所有的线程都共享Java堆吗？**

**所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区( Thread Local**

**Allocation Buffer, TLAB).**

### 2. 堆的内部结构

![](https://cdn.nlark.com/yuque/0/2021/png/2075923/1630938533246-b14648ba-2d03-46b9-a3da-40e883937b98.png)

![](https://cdn.nlark.com/yuque/0/2021/png/2075923/1630938566374-f921dc8f-de9b-4836-ae05-7a8a80c3406c.png)

#### 1. 年轻代与老年代

**存储在JVM中的Java对象可以被划分为两类:**

**一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速**

**●另外一-类对象的生命周期却非常长，在某些极端的情况下还能够与JVM的生命周期保持一致。**

**●Java堆区进一步细分的话，可以划分为年轻代( YoungGen)和老年代( 0ldGen)**

**●其中年轻代又可以划分为Eden空间、Survivor0空 间和Survivor1空间(有时也叫做from区、to区)**

![](https://cdn.nlark.com/yuque/0/2021/png/2075923/1630938649771-71a61fbb-ad91-4ae3-8519-b2ab92c9c2f1.png)

1. **几乎所有的Java对象都是在Eden区被new出来的。**
2. **绝大部分的Java对象的销毁都在新生代进行了。**
3. **IBM公司的专门研究表明，新生代中80%的对象都是“朝生夕死”的。**

### 3. **如何设置堆内存大小?**

#### 1. 如何设置堆内存大小?

**●Java堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，大家可以**

**通过选项”-Xmx”和”-Xms”来进行设置。**

**●-Xms”用于表示堆区的起始内存，等价于-XX:InitialHeapSize**

**●“-Xmx”则用于表示堆区的最大内存，等价于-XX:MaxHeapSize**

**,一旦堆区中的内存大小超过“-Xmx”所指定的最大内存时，将会抛出**

**OutOfMemoryError异常。**

**通常会将-Xms 和-Xmx两个参数配置相同的值，其目的是为了能够在java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能。**

**●heap默认最大值计算方式:如果物理内存少于192M,那么heap最大值为物理内存的一半。如果物理内存大于等于1G, 那么heap的最大值为物理内存的1/4。**

**●heap默认最小值计算方式:最少不得少于8M，如果物理内存大于等于1G,那么默认值为物理内存的1/64，即1024/64=16M。最小堆内存在jvm启动的时候就会被初始化。**

#### 2. 如何设置新生代与老年代比例?

![](https://cdn.nlark.com/yuque/0/2021/png/2075923/1630939266963-d74e4b4d-9f94-4c5f-89a7-ba40425f3ffc.png)

#### 3. 如何设置Eden、幸存者区比例?

**在HotSpot中， Eden空间和另外两个Survivor空间缺省所占的比例是8:1:1**

**当然开发人员可以通过选项“-XX:SurvivorRatio"调整这个空间比例。比如**

**- XX: SurvivorRatio=8**

### 4. 对象分配金句

**对象分配金句**

**为新对象分配内存是一件非常严谨和复杂的任务，JVM的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑GC执行完内存回收后是否会在内存空间中产生内存碎片。**

**金句:, 针对幸存者s0,s1区的总结:复制之后有交换，谁空谁是to.**

**●关于垃圾回收:**

**频繁在新生区收集**

**很少在养老区收集**

**几乎不在永久区/元空间收集**

#### 1. 过程

**过程剖析**

**1.new的对象先放伊甸园区。此区有大小限制。**

**2.当伊甸园的空间填满时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收(MinorGC/YGC)，将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区**

**3.然后将伊甸园中的剩余对象移动到幸存者0区。**

**4.如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区的，如果没有回收，就会放到**

**幸存者1区。**

**5.如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区。**

**6.啥时候能去养老区呢?可以设置次数。默认是15次。**

**●可以设置参数: - XX: MaxTenuringThreshold=`<N>`设置对象晋升老年代的年龄阈值**

**7.在养老区，相对悠闲。当养老区内存不足时，再次触发GC: Major GC，进行养老区的内存清理。**

**8.若养老区执行了Major GC之后发现依然无法进行对象的保存，就会产生00M异常java. lang. OutOfMemoryError: Java heap space**

#### 2.  **分配策略**

**内存分配策略(或对象提升(promotion)规则):**

**如果对象在Eden出生并经过第一次MinorGC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并将对象年龄设为1。对象在Survivor区中每熬过-次MinorGC，年龄就增加1岁，当它的年龄增加到-定程度 (默认为15 岁，其实每 个JVM、每个GC都有所不同)时，就会被晋升到老年代中。**

#### 3. 内存分配原则

**针对不同年龄段的对象分配原则如下所示:**

**优先分配到Eden**

**●大对象直接分配到老年代 I**

**●尽量避免程序中出现过多的大对象**

**●长期存活的对象分配到老年代**

**动态对象年龄判断**

**●如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年**

**龄大于或等于该年龄的对象可以直接进入老年代，无须等到**

**MaxTenuringThreshold中要求的年龄。**

**●空间分配担保**

**●XX: HandlePromotionFailure**

#### 4. 空间分配担保 -XX:HandlePromotionFailure

**在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的**

**总空间，**

**●如果大于，则此次Minor GC是安全的**

**●如果小于，则虚拟机会查看-XX:HandlePromotionFailure设置值是否允许担保失败如果HandlePromotionFailure=true,那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小，如果大于，则尝试进行一-次Minor GC，但这次Minor GC依然是有风险的;如果小于或者HandlePromotionFailure=false,则改为进行一次Full GC。**

**在JDK 6 Update 24之后，HandlePromotionFailure 参数不会再影响到虚拟机的空间分配**

**担保策略，观察OpenJDK 中的源码变化，虽然源码中还定义了HandlePromot ionFailure参数，但是在代码中已经不会再使用它。JDK 6 Update 24之 后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则将进行Fu1lGC。**

### 5. 解释MinorGC、 MajorGC、FullGC

#### 1. 概述

**JVM在进行GC时，并非每次都对上面三个内存(新生代、老年代;方法区)区域一起回收的，大**

**部分时候回收的都是指新生代。**

**针对HotSpot VM的实现，它里面的GC按照回收区域又分为两大种类型:**

**●一种是部分收集(Partial GC)**

**●一种是整堆收集(Full GC)**

**●部分收集:不是完整收集整个Java堆的垃圾收集。其中又分为:**

**●新生代收集(Minor GC / Young GC) :只是新生代(Eden\S0,S1)的垃圾收集**

**●老年代收集(Major GC / 0ld GC) :只是老年代的垃圾收集。**

**●目前，只有CMS GC会有单独收集老年代的行为。**

**注意，很多时候Major GC会和Full GC混淆使用，需要具体分辨是老年代回收**

**还是整堆回收。**

**●混合收集(Mixed GC): 收集整个新生代以及部分老年代的垃圾收集。**

**目前，只有G1 GC会有这种行为**

**●整堆收集(Full GC):收集整个java堆和方法区的垃圾收集。**

#### 2. **年轻代GC (Minor GC) 触发机制:**

**●当年轻代空间不足时，就会触发Minor GC。这里的年轻代满指的是Eden区满，**

**Survivor满不会引发GC。( 每次Minor GC会清理年轻代的内存。)**

**●因为Java 对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收**

**速度也比较快。这一定义既清晰又易于理解。**

**●Minor GC会引发STW，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行**

![](https://cdn.nlark.com/yuque/0/2021/png/2075923/1630940380966-9b04fc6b-7a80-41d7-af73-c4b1f26b93e9.png)

#### 3. **MajorGC触发机制**

**老年代GC (Major GC/Full GC) 触发机制:**

**●指发生在老年代的GC，对象从老年代消失时，我们说“Major GC” 或“Full GC”发生**

**●出现了Major GC，经常会伴随至少-次的Minor GC (但非绝对的， 在Parallel**

**Scavenge收集器的收集策略里就有直接进行MajorGC的策略选择过程)。**

**●也就是在老年代空间不足时，会先尝试触发Minor GC。 如果之后空间还不足，则触发Major GC**

**●Major GC的速度一般会比Minor GC慢10倍以上，STW的时间更长。**

**●如果Major GC后，内存还不足，就报OOM了。**

#### 4. FulIGC触发机制

**触发Full GC执行的情况有如下五种:**

**(1)调用System.gc()时，系统建议执行Full GC，但是不必然执行**

**(2)老年代空间不足**

**(3)方法区空间不足**

**(4)通过Minor GC后进入老年代的平均大小大于老年代的可用内存**

**(5)由Eden区、survivor space0 (From Space) 区向survivor space1 (To Space)**

**区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小**

**说明:**** full gc是开发或调优中尽量要避免的。这样暂时时间会短一些。**

**在默认情况下，通过System. gc( )或者Runtime . getRuntime().gc()的调用，会显式触发Full GC，同时对老年代和新生代进行回收，尝试释放被丢弃对象占用的内存。**

**然而System. gc()调用附带一个免责声明，无法保证对垃圾收集器的调用。**

**JVM实现者可以通过System. gc()调用来决定JVM的GC行为。而一般情况下，垃圾回收应该是自动进行的，无须手动触发，否则就太过于麻烦了。在一些特殊情况 下，如我们正在编写一个性能基准，我们可以在运行之间调用System.gc()。**

### 6. OOM如何解决

**O0M如何解决**

**1、要解决00M异常或heap space的异常， 般的手段 是首先通过内存映像分析工具 (如Eclipse Memory Analyzer) 对dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏(Memory Leak) 还是内存溢出(Memory Overflow) 。**

**2、如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots 的引用链。于是就能找到泄漏对象是通过怎样的路径与GCRoots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息，以及GC Roots 引用链的信息，就可以比较准确地定位出泄漏代码的位置。**

**3、如果不存在内存泄漏，换句话说就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数(-Xmx与-Xms) ，与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。**

### 7. 堆空间分代思想

**经研究，不同对象的生命周期不同。70%-99%的对象是临时对象。**

**●新生代:有Eden、 两块大小相同的Survivor(又称为from/to, s0/s1)构成， to总**

**为空。**

**●老年代:存放新生代中经历多次GC仍然存活的对象。**

**为什么需要把Java堆分代?不分代就不能正常工作了吗? **

**其实不分代完全可以，分代的唯一 理由就是优化GC性能。如果没有分代，那所有的对象都在一块，就如同把一一个学校的人都关在一一个教室。GC的时候要找到哪些对象没用，这样就会对堆的所有区域进行扫描。而很多对象都是朝生夕死的，如果分代的话，把新创建的对象放到某一地方，当GC的时候先把这块存储“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。**

### 8. 快速分配策略: TLAB

#### 1. 为什么有TLAB (Thread Local Allocation Buffer) ?

**堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据**

**●由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的**

**●为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。**

**所以，多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为快速分配策略。**

#### 2. 什么是TLAB?

**●从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，JVM为每个线程分配了一个**

**私有缓存区域，它包含在Eden空间内。**

**●据我所知所有OpenJDK衍生出来的JVM都提供了TLAB的设计。**

![](https://cdn.nlark.com/yuque/0/2021/png/2075923/1630940851722-466de84e-c4da-4d51-8fef-34b78e80433f.png)

#### 3. TLAB的再说明:

**尽管不是所有的对象实例都能够在TLAB中成功分配内存，但JVM确实是将TLAB作为内存分配的首选。**

**在程序中，开发人员可以通过选项“-XX:+/-UseTLAB”设置是否开启TLAB空间。**

**默认情况下，TLAB空间的内存非常小，仅占有整个Eden空间的1%，当然我们可以通过选项“-XX: TLABWasteTargetPercent”设置TLAK空间所占用Eden空间的百分比大小。**

**●-旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在Eden空间中分配内存。**

![](https://cdn.nlark.com/yuque/0/2021/png/2075923/1630940912760-47297452-a94c-42bf-ac8a-0e76c9604fdc.png)

## 对象内存布局

### 1. 你又几种方式创建线程

**new  xxx**

**变形1: Xxx的静态方法**

**变形2: XxxBuilder/XxxFactory的静态方法**

**Class的newInstance():反射的方式，只能调用空参的构造器，权限必须是public**

**Constructor的newInstance(xx):反射的方式，可以调用空参、带参的构造器，权限没有要求，实用性更，**

**使用clone():不调用任何构造器，当前类需要实现Cloneable接口，实现clone()， 默认浅拷贝**

**使用反序列化:从文件中、数据库中、网络中获取一个对象的二进制流，反序列化为内存中的对象**

**第三方库Objenesis,利用了asm字节码技术，动态生成Constructor对象国**

### 2. 创建对象的步骤

#### 2.1 从字节码角度看待对象创建过程

![](https://cdn.nlark.com/yuque/0/2021/png/2075923/1631020561929-44c7242e-ede9-45d7-94aa-902e33b53a02.png)

#### 2.2 对象的访问定位

**句柄访问**

![](https://cdn.nlark.com/yuque/0/2021/png/2075923/1631021423329-92b2c2c5-c5a7-4c1b-9632-fb885b87c9b9.png)

**直接使用指针访问**

**HotSpot使用哪种方式的呢?**

**直接使用指针访问**

## 面试题

### 1. 问题一: 栈溢出的情况?

**栈溢出:Stack0verflowError;**

**举个简单的例子:在main方法中调用main方法，就会不断压栈执行，直到栈溢出;**

**栈的大小可以是固定大小的，也可以是动态变化(动态扩展)的。**

**如果是固定的，可以通过-Xss设置栈的大小;**

**如果是动态变化的，当栈大小到达了整个内存空间不足了，就是抛出OutOfMemory异常(java.lang. OutOfMemoryError)**

### 2. 问题二: 调整栈大小，就能保证不出现溢出吗?

**不能。因为调整栈大小，只会减少出现溢出的可能，栈大小不是可以无限扩大的，所以不能保证不出现溢出**

### 3. 问题三:分配的栈内存越大越好吗?

**不是，因为增加栈大小，会造成每个线程的栈都变的很大，使得一定的栈空间下，能创建的线程数量会变小**

### 4. 问题四:垃圾回收是否会涉及到虚拟机栈?

**不会;垃圾回收只会涉及到方法区和堆中，方法区和堆也会存在溢出的可能;**

**程序计数器，只记录运行下一行的地址，不存在溢出和垃圾回收;**

**虚拟机栈和本地方法栈，都是只涉及压栈和出栈，可能存在栈溢出，不存在垃圾回收。**

### 5. 问题五:方法中定义的局部变量是否线程安全?

### 6. Java 堆的结构是什么样子的? (猎聘)

**JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和**

**Survivor (字节跳动)**

**堆里面的分区: Eden, survival (from+ to)，老年代，各自的特点。 (京东-物流**

**堆的结构?为什么两个survivor区?**

**(蚂蚁金服)**

**Eden和Survior的比例分配 (蚂蚁金服)**

**JVM内存分区，为什么要有新生代和老年代(小米)**

**JVM的内存结构，Eden和Survivor比例。 (京东)**

**JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和**

**Survivor. (京东)**

**JVM内存分区，为什么要有新生代和老年代?**

**(美团)**

**JVM的内存结构，Eden和Survivor比例。 (京东)**

### 7. 什么时候对象会进入老年代? (渣打银行)

**什么时候对象会进入老年代? ( 顺丰)**

**问什么幸存者区15次进入老年区，懂原理吗? (58)**

**JVM的伊甸园区，from区， to区的比例是否可调? ( 花旗银行)**

**JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代(字节跳动)**

**什么时候对象会进入老年代? ( 字节跳动)**

**对象在堆内存创建的生命周期(蚂蚁金服)**

**重点讲讲对象如何晋升到老年代，几种主要的JVM参数( 蚂蚁金服)**

**新生代和老年代的内存回收策略(蚂蚁金服)**

**什么时候对象可以被收回?(蚂蚁金服)**

### 8. 堆大小通过什么参数设置?(阿里)

**初始堆大小和最大堆大小一样，问这样有什么好处?**

**(亚信)**

**JVM中最大堆大小有没有限制? (阿里)**

### 9. **什么是空间分配担保策略? (渣打银行)**

**什么是空间分配担保策略? (顺丰)**

**什么是空间分配担保策略? (腾讯、百度)**

### 10. Minor GC与Full GC分别在什么时候发生? ( 腾讯)

**老年代的垃圾回收机制什么时候触发，自动触发的阈值是多少(蚂蚁金服)**

**新生代的垃圾回收什么时候触发( 蚂蚁金服)**

**简述Java内存分配与回收策略以及MinorGC和MajorGC(国美)**

**什么时候发生Full GC (58)**

**简述Java内存分配与回收策略以及Minor GC和Major GC ( 百度)**

**JVM垃圾回收机制，何时触发Minor GC等操作( 蚂蚁金服)**

**JVM的一次完整的GC流程(从ygc到fgc)是怎样的(蚂蚁金服)**

**描述JVM中一次full gc过程(腾讯)**

**什么情况下触发垃圾回收? (阿里)**

**新生代的垃圾回收什么时候触发(花旗银行)**

**老年代的垃圾回收机制什么时候触发，自动触发的阈值是多少(花旗银行)**
