/**
 
区间交集

题目描述
给若干个区间，区间数少于1000，区间范围[-10000,10000]。当区间数少于2个时输出None。
当各个区间有交集的时候取交集，再求交集的并集

样例输入
1 3 2 4 4 8 5 9
样例输出
2 3 4 4 5 8
说明
[1,3]、[2,4]、[4,8]、[5,9] 四个区间
[1,3]与[2,4]交集为[2,3]，[1,3]与[4,8]、[5,9]没有交集
[2,4]与[4,8]]交集为[4,4]。[2,4]与[5,9]没有交集
[4,8]与[5,9]的交集为[5,8]
所以最终的输出为[2,3]、[4,4]、[5,8]

样例输入
1 2 3 4
样例输出
None

样例输入
1 6 2 5 5 7
样例输出
2 6
说明
[1,6]、[2,5]的交集为[2,5]，[1,6]、[5,7]的交集为[5,6]
[2,5]、[5,7]的交集为[5,5]
最后的输出为：2 6

【分析】
思路比较明确，通过比较区间端点的大小先找交集

问题在于如何求并集，可以设置一个长为20001的数组，对于交集，就将它们的位置置为1
但有一个细节是，对于 [2,3]、[4,4] 它们是不相交的，它们之间还有 (3,4) ，所以上述做法在边界判定时会有问题，有一种思路是将数组长设置为40000，在两个数之间增加一个0.5

我的想法是将找到的所有交集按照左边界、右边界大小排序，此时第一个区间的左边界一定是最小的，然后依次向后判断是否有区间包含它的右边界，如果包含，两个区间可以合并，当有一个区间的左边界大于当前节点的右边界时，说明向后已不存在交集，继续找下一个区间的交集。

例如：
对于 1 6 2 5 5 7 ， 可以找到交集 [2,5]、[5,6]、[5,5] ，排序后得到 [2,5]、[5,5]、[5,6] ，从 [2,5] 开始找交集，新的交集的左边界就为 2（不存在比它还小的区间端点），向后找判断右边界；得到 [5,5] 的左边界为 5 ，不大于 [2,5] 的右边界，说明两个区间存在交集，可以合并，此时交集的右边界从 5 变成了 5 ，继续向后找，找到 [5,6] ，新交集的右边界置为 6 ，对于已经参与合并的区间 [5,5]、[5,6] ，将其值进行标记，表示它们已经被取并集，不再参与之后的找并集，这样将交集数组全部遍历一遍，就能得到所有的并集。
————————————————
版权声明：本文为CSDN博主「下一个路口遇见你48」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/m0_56229413/article/details/117741750

给若干个区间，区间数少于1000，区间范围[-10000,10000]。当区间数少于2个时输出None。当各个区间有交集的时候取交集，再求交集的并集。具体看下面的列子
1、如:[1,3]、[2,4]、[4,8]、[5,9]4个区间，
输入demo:1 3 2 4 4 8 5 9
[1,3]与[2,4]交集为[2,3],。。[1,3]与[4,8]、[5,9]没有交集。
[2,4]与[4,8]]交集为[4,4]。[2,4]与[5,9]没有交集。
[4,8]与[5,9]的交集为[5,8]
所以最终的输出为[2,3]、[4,4]、[5,8]
输出demo:2 3 4 4 5 8
2、如:[1,2]、[3,4]2个区间，
最后输出为None
3、如:[1,6]、[2,5]、[5,7]3个区间，
[1,6]、[3,5]的交集为[2,5]，，，[1,6]、[5,7]的交集为[5,7]
[2,5]、[5,7]的交集为[5,5]
最后的输出为：2 7
 */
demo("1 3 2 4 4 8 5 9");
demo("5 9 4 8 1 3 2 4");
demo("0 3 1 4 4 7 5 8");
function demo(input) {
  // 获取输入

  // 将其存入一个数组，每两位表示一个区间
  const arr = input.split(" ").map((x) => parseInt(x, 10));
  const len = arr.length;

  // 存储找到的所有交集
  const res = [];

  // 从第一个区间向后找交集
  for (let i = 0; i < len; i += 2) {
    // 从当前区间的下一个区间开始
    for (let j = i + 2; j < len; j += 2) {
      // 两个区间左侧的较大值作为交集的左边界
      let left = Math.max(arr[i], arr[j]);
      // 两个区间右侧的较小值作为交集的右边界
      let right = Math.min(arr[i + 1], arr[j + 1]);
      if (left <= right) {
        // 当左边界小于等于右边界时，两个区间存在交集，记录
        res.push([left, right]);
      }
    }
  }

  // 将找到的交集数组按照左边界大小、右边界大小排序，方便后续取并集
  res.sort((a, b) => {
    if (a[0] === b[0]) {
      return a[1] - b[1];
    } else {
      return a[0] - b[0];
    }
  });

  // 求并集
  const range = res.length;
  const RES = [];
  for (let i = 0; i < range; i++) {
    // 每次找到以当前左端点开始的
    left = res[i][0];
    right = res[i][1];

    for (let j = i + 1; j < range; j++) {
      if (res[j] === 0) {
        // 该区间已被其他区间合并，跳过
        continue;
      }

      if (res[j][0] > right) {
        // 该区间的左边界已经大于当前要找的区间的右边界，说明后面已经不存在交集
        break;
      }

      // 两个区间存在交集，右边界置为它们中的较大值，并且该区间置为0，之后不再遍历
      right = Math.max(right, res[j][1]);
      res[j] = 0;
    }

    // 保存当前找的交集
    RES.push(left, right);
  }

  console.log(RES.length === 0 ? "None" : RES.join(" "));
}
